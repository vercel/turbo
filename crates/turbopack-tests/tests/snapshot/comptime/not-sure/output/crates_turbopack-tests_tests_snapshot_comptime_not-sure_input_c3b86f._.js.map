{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/crates/turbopack-tests/tests/snapshot/comptime/not-sure/input/module.js"],"sourcesContent":["module.exports = {};\n"],"names":[],"mappings":"AAAA,OAAO,OAAO,GAAG,CAAC"}},
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/crates/turbopack-tests/tests/snapshot/comptime/not-sure/input/index.ts"],"sourcesContent":["import type { FetchEventResult } from \"./module\";\nimport type { TextMapSetter } from \"./module\";\nimport type { SpanTypes } from \"./module\";\nimport { LogSpanAllowList, NextVanillaSpanAllowlist } from \"./module\";\n\nimport type {\n  ContextAPI,\n  Span,\n  SpanOptions,\n  Tracer,\n  AttributeValue,\n  TextMapGetter,\n} from \"./module\";\n\nlet api: typeof import(\"./module\");\n\n// we want to allow users to use their own version of @opentelemetry/api if they\n// want to, so we try to require it first, and if it fails we fall back to the\n// version that is bundled with Next.js\n// this is because @opentelemetry/api has to be synced with the version of\n// @opentelemetry/tracing that is used, and we don't want to force users to use\n// the version that is bundled with Next.js.\n// the API is ~stable, so this should be fine\nif (process.env.NEXT_RUNTIME === \"edge\") {\n  api = require(\"./module\");\n} else {\n  try {\n    api = require(\"./module\");\n  } catch (err) {\n    api = require(\"./module\");\n  }\n}\n\nconst { context, propagation, trace, SpanStatusCode, SpanKind, ROOT_CONTEXT } =\n  api;\n\nconst isPromise = <T>(p: any): p is Promise<T> => {\n  return p !== null && typeof p === \"object\" && typeof p.then === \"function\";\n};\n\nexport class BubbledError extends Error {\n  constructor(\n    public readonly bubble?: boolean,\n    public readonly result?: FetchEventResult\n  ) {\n    super();\n  }\n}\n\nexport function isBubbledError(error: unknown): error is BubbledError {\n  if (typeof error !== \"object\" || error === null) return false;\n  return error instanceof BubbledError;\n}\n\nconst closeSpanWithError = (span: Span, error?: Error) => {\n  if (isBubbledError(error) && error.bubble) {\n    span.setAttribute(\"next.bubble\", true);\n  } else {\n    if (error) {\n      span.recordException(error);\n    }\n    span.setStatus({ code: SpanStatusCode.ERROR, message: error?.message });\n  }\n  span.end();\n};\n\ntype TracerSpanOptions = Omit<SpanOptions, \"attributes\"> & {\n  parentSpan?: Span;\n  spanName?: string;\n  attributes?: Partial<Record<AttributeNames, AttributeValue | undefined>>;\n  hideSpan?: boolean;\n};\n\ninterface NextTracer {\n  getContext(): ContextAPI;\n\n  /**\n   * Instruments a function by automatically creating a span activated on its\n   * scope.\n   *\n   * The span will automatically be finished when one of these conditions is\n   * met:\n   *\n   * * The function returns a promise, in which case the span will finish when\n   * the promise is resolved or rejected.\n   * * The function takes a callback as its second parameter, in which case the\n   * span will finish when that callback is called.\n   * * The function doesn't accept a callback and doesn't return a promise, in\n   * which case the span will finish at the end of the function execution.\n   *\n   */\n  trace<T>(\n    type: SpanTypes,\n    fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>\n  ): Promise<T>;\n  trace<T>(\n    type: SpanTypes,\n    fn: (span?: Span, done?: (error?: Error) => any) => T\n  ): T;\n  trace<T>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>\n  ): Promise<T>;\n  trace<T>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: (span?: Span, done?: (error?: Error) => any) => T\n  ): T;\n\n  /**\n   * Wrap a function to automatically create a span activated on its\n   * scope when it's called.\n   *\n   * The span will automatically be finished when one of these conditions is\n   * met:\n   *\n   * * The function returns a promise, in which case the span will finish when\n   * the promise is resolved or rejected.\n   * * The function takes a callback as its last parameter, in which case the\n   * span will finish when that callback is called.\n   * * The function doesn't accept a callback and doesn't return a promise, in\n   * which case the span will finish at the end of the function execution.\n   */\n  wrap<T = (...args: Array<any>) => any>(type: SpanTypes, fn: T): T;\n  wrap<T = (...args: Array<any>) => any>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: T\n  ): T;\n  wrap<T = (...args: Array<any>) => any>(\n    type: SpanTypes,\n    options: (...args: any[]) => TracerSpanOptions,\n    fn: T\n  ): T;\n\n  /**\n   * Starts and returns a new Span representing a logical unit of work.\n   *\n   * This method do NOT modify the current Context by default. In result, any inner span will not\n   * automatically set its parent context to the span created by this method unless manually activate\n   * context via `tracer.getContext().with`. `trace`, or `wrap` is generally recommended as it gracefully\n   * handles context activation. (ref: https://github.com/open-telemetry/opentelemetry-js/issues/1923)\n   */\n  startSpan(type: SpanTypes): Span;\n  startSpan(type: SpanTypes, options: TracerSpanOptions): Span;\n\n  /**\n   * Returns currently activated span if current context is in the scope of the span.\n   * Returns undefined otherwise.\n   */\n  getActiveScopeSpan(): Span | undefined;\n\n  /**\n   * Returns trace propagation data for the currently active context. The format is equal to data provided\n   * through the OpenTelemetry propagator API.\n   */\n  getTracePropagationData(): ClientTraceDataEntry[];\n}\n\ntype NextAttributeNames =\n  | \"next.route\"\n  | \"next.page\"\n  | \"next.rsc\"\n  | \"next.segment\"\n  | \"next.span_name\"\n  | \"next.span_type\"\n  | \"next.clientComponentLoadCount\";\ntype OTELAttributeNames = `http.${string}` | `net.${string}`;\ntype AttributeNames = NextAttributeNames | OTELAttributeNames;\n\n/** we use this map to propagate attributes from nested spans to the top span */\nconst rootSpanAttributesStore = new Map<\n  number,\n  Map<AttributeNames, AttributeValue | undefined>\n>();\nconst rootSpanIdKey = api.createContextKey(\"next.rootSpanId\");\nlet lastSpanId = 0;\nconst getSpanId = () => lastSpanId++;\n\nexport interface ClientTraceDataEntry {\n  key: string;\n  value: string;\n}\n\nconst clientTraceDataSetter: TextMapSetter<ClientTraceDataEntry[]> = {\n  set(carrier, key, value) {\n    carrier.push({\n      key,\n      value,\n    });\n  },\n};\n\nclass NextTracerImpl implements NextTracer {\n  /**\n   * Returns an instance to the trace with configured name.\n   * Since wrap / trace can be defined in any place prior to actual trace subscriber initialization,\n   * This should be lazily evaluated.\n   */\n  private getTracerInstance(): Tracer {\n    return trace.getTracer(\"next.js\", \"0.0.1\");\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 153, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 157, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 161, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}