---
title: The Task Graph
description: Turborepo builds a Task Graph based on your configuration and repository structure.
---

# The Task Graph

In [the previous section][2], we talked about how Turborepo uses `turbo.json` to express
how tasks relate to each other. You can think of these relationships as dependencies between
tasks, but we have a more formal name for them: the Task Graph.

Turborepo uses a data structure called a [directed acyclic graph (DAG)][1] to
understand your repository and its tasks. A graph is made up of "nodes" and
"edges". In our Task Graph, the nodes are tasks and the edges are the
dependencies. A _directed_ graph indicates that the edges connecting each node
have a direction, so we can say that if Task A depends on Task B (or the other
way around). The direction of the edge depends on which task depends on which.

For example, let's say you have a monorepo with an application `apps/web` that
depends on two packages: `@repo/ui` and `@repo/utils`:

```
my-monorepo
└─ apps
 └─ web
└─ packages
 └─ ui
 └─ utils
```

And a `build` task depends on `^build`:

```json
{
  "pipeline": {
    "build": {
      "dependsOn": ["^build"]
    }
  }
}
```

Turborepo will build a task graph like this:

![Task graph visualization. The diagram has one node at the top named "apps/web" with two lines that connect to other nodes, "packages/ui" and "packages/utils" respectively.](/images/docs/simple-task-graph.png)

## Transit Nodes

A challenge when building a Task Graph is handling nested dependencies. For
example, let's say your monorepo has a `docs` app that depends on the `ui`
package, which depends on the `core` package:

```
my-monorepo
└─ apps
 └─ docs
└─ packages
 └─ ui
 └─ core
```

Let's assume the `docs` app and the `core` package each have a `build` task, but
the `ui` package does not. You also have a `turbo.json` that configures the
`build` task the same way as above with `"dependsOn": ["^build"]`. When you run
`turbo run build`, what would you expect to happen?

Turborepo will build this Task Graph:

![A Task Graph visualization with a Transit Node. The diagram has one node at the top named "apps/doc" with a line that connects to a "packages/ui" node. This node does not have a "build" task. The "packages/ui" node has another line to a "packages/core" node that does have a "build" task.](/images/docs/transitive-nodes.png)

The `ui` package is included in the graph, even though it is only a transitive
dependency of the `docs` app. You can think of this graph in a series of steps:

- The `docs` app only depends on `ui`.
- The `ui` package does **not** have a build script.
- The `ui` package's _dependencies_ have a `build` script, so the task graph knows to include those.

Turborepo calls the `ui` package a Transit Node in this scenario, because it
doesn't have its own `build` script. Since it doesn't have a `build` script,
Turborepo won't execute anything for it, but it's still part of the graph for
the purpose of including its dependencies.

### Transit Nodes as entry points

But what if the `docs/` package didn't implement the `build` task? What would you expect to happen
in this case? Should the `ui` and `core` packages still execute their build tasks? Should _anything_
happen here?

Turborepo's mental model is that all nodes in the Task Graph are the same. In other words,
Transit Nodes are included in the graph regardless of where they appear in the graph.

What if we didn't include Transit Nodes in the graph?

In the monorepo described above, we're including the Transit Node (and its
dependencies) by default. This is an important distinction to make sure that
Turborepo misses the cache as you'd expect.

If the default was to **exclude** Transit Nodes, a source code change in the
`core` package would not invalidate the cache for the `docs` app for
`turbo run build`, using stale code from previous iterations of your `core`
package.

[1]: https://en.wikipedia.org/wiki/Directed_acyclic_graph
[2]: /repo/docs/core-concepts/task-dependencies
