---
title: The Task Graph
description: Turborepo builds a Task Graph based on your configuration and repository structure.
---

# The Task Graph

In [the previous section][3], we talked about how Turborepo uses `turbo.json` to express
how tasks relate to each other. You can think of these relationships as dependencies between
tasks, but we have a more formal name for them: the task graph.

Turborepo uses a data structure called a [directed acyclic graph (DAG)][1] to
understand your repository and its tasks. A graph is made up of nodes and edges.
In the case of a task graph, the nodes are tasks and the edges are the dependencies.
A _directed_ graph means that the edges have a direction, so we can say that
TaskA has a dependency on TaskB, or the other way around. The direction of the edge
depends on which way the dependency goes.

For example, let's say you have a monorepo with an application `apps/web` that depends on two
packages: `@repo/ui` and `@repo/utils`:

```
my-monorepo
└─ apps
 └─ web
└─ packages
 └─ ui
 └─ utils
```

And a `build` task depends on `^build`:

```json
{
  "pipeline": {
    "build": {
      "dependsOn": ["^build"]
    }
  }
}
```

Turborepo will build a task graph like this:

![Task graph visualization. The diagram has one node at the top named "apps/web" with two lines that connect to other nodes, "packages/ui" and "packages/utils" respectively.](/images/docs/simple-task-graph.png)

## Phantom Nodes

A challenge when building a task graph is handling nested dependencies. For
example, let's say your monorepo has a `docs` app that depends on the `ui`
package, which depends on the `core` package:

```
my-monorepo
└─ apps
 └─ docs
└─ packages
 └─ ui
 └─ core
```

Let's assume the `docs` app and the `core` package each have a `build` task, but
the `ui` package does not. You also have a `turbo.json` that configures the
`build` task the same way as above with `"dependsOn": ["^build"]`. When you run
`turbo run build`, what would you expect to happen?

Turborepo will build this Task Graph:

![A Task Graph visualization with a Phantom Node. The diagram has one node at the top named "apps/doc" with a line that connects to a "packages/ui" node. This node does not have a "build" task. The "packages/ui" node has another line to a "packages/core" node that does have a "build" task.](/images/docs/phantom-nodes.png)

The `ui` package is included in the graph, even though it is only a
transitive dependency of the `docs` app. You can think of this graph being built in a series of steps:

- The `docs` app only depends on `ui`.
- The `ui` package doesn't have a build script.
- The `ui` package's _dependencies_ have a `build` script, so the task graph knows to include those.

Turborepo calls the `ui` package a Phantom Node. Since it doesn't have a `build`
script, Turborepo won't execute anything for it, but it's still part of the
graph for the purpose of including its dependencies.

### What if we didn't include Phantom Nodes in the graph?

In the workspace described above, we're including the Phantom Node (and its
dependencies) by default. This is an important distinction to make sure that
Turborepo misses the cache as you'd expect.

If the default was to **exclude** Phantom Nodes, you could make a source code
change in the `core` package but still hit cache for the `docs` app the next
time you try `turbo run build`, using stale code from previous iterations of
your `core` package.

[1]: https://en.wikipedia.org/wiki/Directed_acyclic_graph
[2]: https://vercel.com/blog/how-to-scale-a-large-codebase
[3]: /repo/docs/core-concepts/task-dependencies
