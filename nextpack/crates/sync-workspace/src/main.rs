use std::{
    fs::File,
    io::{Read, Write},
};

use anyhow::Result;
use indoc::indoc;
use toml::{Table, Value};

const NEXT_PATH: &str = "./next.js/packages/next-swc/";
const TURBO_PATH: &str = "./turbo-crates/";
const DEFAULT_TOML: &str = indoc!(
    r#"
    [workspace]
    resolver = "2"

    members = ["crates/*"]
"#
);

fn read_toml(file: &str) -> Table {
    let mut cargo_toml = String::new();
    let n = File::open(file)
        .expect(&format!("failed to open {file}"))
        .read_to_string(&mut cargo_toml)
        .expect(&format!("failed to read {file}"));
    cargo_toml.truncate(n);

    toml::from_str(&cargo_toml).expect(&format!("failed to parse {file}"))
}

fn main() -> Result<()> {
    println!("Synchronizing nextpack Cargo.toml with Turbo and Next.jsâ€¦");

    let turbo_toml = read_toml("../Cargo.toml");
    let next_toml = read_toml(&[NEXT_PATH, "Cargo.toml"].concat());

    let mut cargo_toml: Table =
        toml::from_str(DEFAULT_TOML).expect("failed to parse default Cargo.toml");

    let members = cargo_toml["workspace"]["members"]
        .as_array_mut()
        .expect("cargo_toml[workspace][members]");
    members.extend(
        // Turbo crates are included in members, only Turbopack crates are in default-members.
        turbo_toml["workspace"]["default-members"]
            .as_array()
            .unwrap()
            .iter()
            // exclude xtask
            .filter(|member| member.as_str().unwrap().contains("crates/"))
            .map(|s| Value::String(format!("{TURBO_PATH}{}", s.as_str().unwrap()))),
    );
    members.extend(
        next_toml["workspace"]["members"]
            .as_array()
            .unwrap()
            .iter()
            .map(|s| Value::String(format!("{NEXT_PATH}{}", s.as_str().unwrap()))),
    );

    let mut dependencies: Table = turbo_toml["workspace"]["dependencies"]
        .as_table()
        .unwrap()
        .iter()
        .map(|(key, value)| {
            if let Some(attrs) = value.as_table() {
                let remapped = Value::Table(
                    attrs
                        .iter()
                        .map(|(k, v)| {
                            if k == "path" {
                                (
                                    k.clone(),
                                    Value::String(format!("{TURBO_PATH}{}", v.as_str().unwrap())),
                                )
                            } else {
                                (k.clone(), v.clone())
                            }
                        })
                        .collect(),
                );
                (key.clone(), remapped)
            } else {
                (key.clone(), value.clone())
            }
        })
        .collect();

    // Ensure workspace path deps to members at least.
    for member in members.iter() {
        let dep = member.as_str().unwrap();
        if let Some((path, name)) = dep.rsplit_once("/") {
            if path == "crates" {
                // ignore the nexpack helper crates.
                continue;
            }
            if let Some(member_dep) = dependencies.get_mut(name).and_then(|d| d.as_table_mut()) {
                member_dep.insert("path".to_string(), member.clone());
            } else {
                let mut member_dep = Table::new();
                member_dep.insert("path".to_string(), member.clone());
                dependencies.insert(name.to_string(), Value::Table(member_dep));
            }
        }
    }

    // Turbo's workspace dependencies must be duplicated for any of the crates to
    // work, since they expect it to be in the workspace root. But we need to remap
    // any path dependencies to be relative to Turbo's Cargo.toml.
    cargo_toml["workspace"]
        .as_table_mut()
        .unwrap()
        .insert("dependencies".to_string(), Value::Table(dependencies));

    let mut toml_file = File::options()
        .write(true)
        .truncate(true)
        .open("Cargo.toml")?;
    writeln!(toml_file, "# THIS FILE IS AUTOGENERATED BY np-sync-crates")?;
    toml_file.write_all(toml::to_string_pretty(&cargo_toml)?.as_bytes())?;

    Ok(())
}
